;--------------------------------------------------------------------------------------------
;  Copyright (c) Fantaisie Software. All rights reserved.
;  Dual licensed under the GPL and Fantaisie Software licenses.
;  See LICENSE and LICENSE-FANTAISIE in the project root for license information.
;--------------------------------------------------------------------------------------------


CompilerIf #DEBUG
  ;   CompilerIf #CompileLinux
  ;
  ;     ;/* log flags */
  ;     #G_LOG_FLAG_RECURSION		= 1 << 0
  ;     #G_LOG_FLAG_FATAL		    = 1 << 1
  ;
  ;     ;/* GLib log levels */
  ;     #G_LOG_LEVEL_ERROR		  = 1 << 2	;/* always fatal */
  ;     #G_LOG_LEVEL_CRITICAL		= 1 << 3
  ;     #G_LOG_LEVEL_WARNING		= 1 << 4
  ;     #G_LOG_LEVEL_MESSAGE		= 1 << 5
  ;     #G_LOG_LEVEL_INFO		    = 1 << 6
  ;     #G_LOG_LEVEL_DEBUG		  = 1 << 7
  ;
  ;     #G_LOG_LEVEL_MASK		    = ~(#G_LOG_FLAG_RECURSION | #G_LOG_FLAG_FATAL)
  ;
  ;     DisableDebugger
  ;
  ;     ProcedureC GtkErrorHandler(*log_domain, log_level, *message, user_data)
  ;       Protected Message$ = PeekS(*log_domain, -1, #PB_Ascii) + ": " + PeekS(*message)
  ;
  ;
  ;       !EXTRN PB_DEBUGGER_SendError
  ;       !PUSH  dword [p.v_Message$]
  ;       !CALL  PB_DEBUGGER_SendError
  ;       !ADD   esp, 4
  ;
  ;     EndProcedure
  ;
  ;     EnableDebugger
  ;
  ;     g_log_set_handler_(@"Gtk", #G_LOG_LEVEL_ERROR|#G_LOG_FLAG_FATAL, @GtkErrorHandler(), 6)
  ;     g_log_set_handler_(@"Gtk", #G_LOG_LEVEL_CRITICAL, @GtkErrorHandler(), 2)
  ;     g_log_set_handler_(@"Gtk", #G_LOG_LEVEL_WARNING, @GtkErrorHandler(), 2)
  ;
  ;     g_log_set_handler_(@"Gdk", #G_LOG_LEVEL_ERROR|#G_LOG_FLAG_FATAL, @GtkErrorHandler(), 6)
  ;     g_log_set_handler_(@"Gdk", #G_LOG_LEVEL_CRITICAL, @GtkErrorHandler(), 2)
  ;     g_log_set_handler_(@"Gdk", #G_LOG_LEVEL_WARNING, @GtkErrorHandler(), 2)
  ;
  ;     g_log_set_handler_(@"Pango", #G_LOG_LEVEL_ERROR|#G_LOG_FLAG_FATAL, @GtkErrorHandler(), 6)
  ;     g_log_set_handler_(@"Pango", #G_LOG_LEVEL_CRITICAL, @GtkErrorHandler(), 2)
  ;     g_log_set_handler_(@"Pango", #G_LOG_LEVEL_WARNING, @GtkErrorHandler(), 2)
  ;
  ;   CompilerEndIf
  
  ; This might also work on linux... to check
  ;
  CompilerIf #CompileMac
    
    ; NOTE: For this to work, you have to enable the bad malloc traping with an environmentvariable.
    ; SetEnvironmentVariable() has no affect, probably because it must be done before program start.
    ;
    ; Use this before program start:
    ; export MallocBadFreeAbort=1
    ;
    Prototype PB_DEBUGGER_Error(Control, *Message)
    
    DisableDebugger ; important to preserve the line numbers!!
    
    Procedure GetDebuggerErrorFunction()
      
      CompilerIf #PB_Compiler_Processor = #PB_Processor_x64
        ;!extern _PB_DEBUGGER_Error
        ;!MOV rax,_PB_DEBUGGER_Error
      CompilerEndIf
      
      CompilerIf #PB_Compiler_Processor = #PB_Processor_x86
        !extern _PB_DEBUGGER_Error
        !MOV eax,_PB_DEBUGGER_Error
      CompilerEndIf
      
      CompilerIf #PB_Compiler_Processor = #PB_Processor_PowerPC
        !.globl _PB_DEBUGGER_Error
        ! lwa r3,_PB_DEBUGGER_Error
      CompilerEndIf
      
      ProcedureReturn
    EndProcedure
    
    ProcedureC abort_signal(signum.l)
      
      PB_DEBUGGER_Error.PB_DEBUGGER_Error = GetDebuggerErrorFunction()
      
      ; Mark this error as non-continuable
      ;
      PB_DEBUGGER_Error(6, @"free() for a not malloc()'ed Memory!")
      
    EndProcedure
    
    EnableDebugger
    
    #SIGABRT = 6
    
    ; setup the signal handler to catch the signal generated by the above set environment option
    signal_(#SIGABRT, @abort_signal())
    
  CompilerEndIf
  
CompilerEndIf

